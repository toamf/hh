Задание 5
Сценарий контролирует список исходящих tcp-соединений. Относительно каждого выявленного соединения фиксируется время начала соединения (время выявления нового соединения), время окончания соединения (ранее выявленное соединение отсутствует в списке активных соединений), полный путь до исполняемого файла, инициирующего сетевое соединение и атрибуты соединения. Допускается использование временных файлов для хранения промежуточных результатов. Соединения, инициированные программой из файла исключений (exclusion) не учитываются.

На входе:
1. oufile - имя файла с результатом работы программы;
2. exclusion - имя файла, содержащего словарь исключений исполняемых файлов. Имя каждого файла начинается с новой строки. Формат файла: <"полный путь до исполняемого файла">
3. interval - интервал опроса сетевых интерфейсов, в секундах.

На выходе:
1. Заполненный файл outfile. Формат файла.
<start time>:<stop_time>:<l_ip>:<l_port>:<f_ip>:<f_port>:<pid>:<progamm>:<arg>

Здесь:
start_time - время начала соединения stop time - время окончания соединения
l_ір - локальный ІР-адрес
l_port - номер удаленного порта
f_ір - удаленный ІР-адрес
f_port - номер удаленного порта 
pid - идентификатор процесса 
progamm - полный путь к исполняемому файлу 
arg - аргументы, с которыми был запущен файл




#!/bin/bash

# Входные параметры
outfile="connections.txt"
exclusion_file="exclusion.txt"
interval=1  # В секундах

# Чтение файла исключения
declare -a excluded_files
if [[ -f "$exclusion_file" ]]; then
    mapfile -t excluded_files < "$exclusion_file"
fi

# Инициализация списка активных подключений
declare -A active_connections

# Непрерывный мониторинг исходящих TCP-соединений
while true; do
    # Получить список текущих подключений
    connections=$(ss -t -o state established | tail -n+2)

    # Цикл по каждому соединению
    while read -r line; do
        # Разбор информации о подключении
        fields=($line)
        local_ip=${fields[4]%:*}
        local_port=${fields[4]##*:}
        remote_ip=${fields[5]%:*}
        remote_port=${fields[5]##*:}
        pid=${fields[6]}
        inode=${fields[7]}

        # Получить путь к исполняемому файлу и аргументы
        if [[ -n "$pid" ]]; then
            exe_path=$(readlink -f "/proc/$pid/exe")
            exe_args=$(tr '\0' ' ' < "/proc/$pid/cmdline")
        fi

        # Проверьте, следует ли исключить соединение
        exclude=false
        for file_path in "${excluded_files[@]}"; do
            if [[ "$exe_path" == "$file_path" ]]; then
                exclude=true
                break
            fi
        done
        if $exclude; then
            continue
        fi

        # Проверьте, активно ли соединение
        if [[ -n "${active_connections[$inode]}" ]]; then
            # Соединение уже активно, время окончания обновления
            connection_info="${active_connections[$inode]}"
            fields=($connection_info)
            start_time=${fields[0]}
            end_time=$(date +%s)
            active_connections[$inode]="$start_time:$end_time:$local_ip:$local_port:$remote_ip:$remote_port:$pid:$exe_path:$exe_args"
        else
            # Соединение еще не активно, добавить в список
            start_time=$(date +%s)
            active_connections[$inode]="$start_time::${local_ip}:${local_port}:${remote_ip}:${remote_port}:${pid}:${exe_path}:${exe_args}"
        fi
    done <<< "$connections"

    # Проверьте наличие неактивных подключений и запишите в выходной файл
    for inode in "${!active_connections[@]}"; do
        connection_info="${active_connections[$inode]}"
        fields=($connection_info)
        start_time=${fields[0]}
        end_time=${fields[1]}
        if [[ -z "$end_time" ]]; then
            # Соединение все еще активно, пропустить
            continue
        fi
        # Соединение больше не активно, запись в выходной файл
        echo "$connection_info" >> "$outfile"
        unset active_connections[$inode]
    done

    # Дождитесь следующего интервала
    sleep "$interval"
done


Это скрипт Bash, который непрерывно отслеживает исходящие TCP-соединения, записывает информацию о каждом соединении (например, локальные и удаленные IP-адреса, порты, идентификатор процесса и путь к исполняемому файлу) и записывает информацию в файл, если соединение больше не активно. Скрипт принимает следующие входные параметры:

outfile: имя файла для записи информации о подключении. По умолчанию это значение равно "connections.txt ".
exclusion_file: имя файла, содержащего список путей к исполняемым файлам, которые необходимо исключить из мониторинга. По умолчанию это значение равно "exclusion.txt ".
интервал: интервал (в секундах) между проверками активных подключений. По умолчанию это значение равно 1 секунде.
Скрипт сначала считывает файл исключения и сохраняет список путей к исключенным исполняемым файлам в массиве. Затем он инициализирует ассоциативный массив для хранения информации об активных соединениях, где каждый ключ представляет собой индекс (уникальный идентификатор для каждого TCP-соединения), а значение представляет собой строку, содержащую информацию о соединении.

Затем скрипт переходит в непрерывный цикл, где он извлекает список текущих подключений с помощью команды ss и перебирает каждое соединение. Для каждого соединения скрипт анализирует информацию о соединении и извлекает путь к исполняемому файлу и аргументы для процесса, который инициировал соединение. Затем он проверяет, следует ли исключить соединение, основываясь на списке исключенных путей к исполняемым файлам. Если соединение не исключено, скрипт проверяет, является ли соединение уже активным, проверяя, находится ли индекс в массиве активных подключений. Если соединение уже активно, сценарий обновляет время окончания соединения. Если соединение еще не активно, скрипт добавляет его в массив активных подключений с текущим временем в качестве времени начала.

После обработки всех текущих подключений скрипт проверяет наличие неактивных подключений, просматривая массив активных подключений и проверяя, установлено ли время окончания для каждого подключения. Если время окончания установлено, скрипт записывает информацию о соединении в выходной файл и удаляет соединение из массива активных подключений.

Затем скрипт ожидает следующего интервала, прежде чем снова проверять наличие активных подключений.








Чтобы запустить этот сценарий, выполните следующие действия:

Откройте терминал на своем компьютере с Linux.

Перейдите в каталог, в котором находится сценарий, с помощью команды cd.

Убедитесь, что скрипт имеет разрешения на выполнение, выполнив команду chmod +x <scriptname.sh> (замените <scriptname.sh> фактическим именем файла сценария).

Запустите сценарий, выполнив команду ./<scriptname.sh> (замените <scriptname.sh> фактическим именем файла сценария).

Сценарий начнет мониторинг исходящих TCP-соединений и запись информации о подключении в указанный выходной файл. Вы можете завершить сценарий в любое время, нажав Ctrl+C в терминале.