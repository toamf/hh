import cv2
import numpy as np


def create_hologram(image):
    # Применение дискретного преобразования Фурье
    dft = cv2.dft(np.float32(image), flags=cv2.DFT_COMPLEX_OUTPUT)

    # Вычисление магнитуды и фазы
    magnitude, angle = cv2.cartToPolar(dft[:, :, 0], dft[:, :, 1])

    # Создание голограммы
    hologram = np.fft.ifftshift(angle)

    return hologram


# Чтение изображений
img = cv2.imread('happy.png', cv2.IMREAD_GRAYSCALE)
hologram_img = cv2.imread('cat-2.png', cv2.IMREAD_GRAYSCALE)

# Создание голограммы
hologram = create_hologram(hologram_img)

# Преобразование голограммы в бинарную строку
hologram = ''.join([bin(int(pixel))[2:].zfill(8) for pixel in np.uint8(hologram * 255).flatten()])

# Проверка размера изображения
h, w = img.shape
assert h % 8 == 0 and w % 8 == 0, "Размер изображения должен быть кратен 8"
assert h * w // 64 >= len(hologram), "В изображении недостаточно места для голограммы"

hologram_index = 0

# Преобразование изображения
for i in range(0, h, 8):
    for j in range(0, w, 8):
        # Если все биты голограммы уже вставлены, остановимся
        if hologram_index >= len(hologram):
            break

        # Блок 8x8
        block = np.float32(img[i:i + 8, j:j + 8])

        # Применение ДКП
        dct_block = cv2.dct(block)

        # Получение коэффициентов
        coef1, coef2 = dct_block[5, 2], dct_block[3, 5]

        # Высчитывание разности
        diff = abs(coef1 - coef2)

        # Передача бита
        if hologram[hologram_index] == '1':
            if diff <= 25:
                coef1 = coef2 + 25 if coef1 <= coef2 else coef2 - 25
        else:
            if diff >= -25:
                coef2 = coef1 + 25 if coef2 <= coef1 else coef1 - 25

        # Присваивание новых значений
        dct_block[5, 2], dct_block[3, 5] = coef1, coef2

        # Обратное ДКП
        block = cv2.idct(dct_block)

        # Запись в изображение
        # img[i:i + 8, j:j + 8] = np.uint8(block)
        img[i:i + 8, j:j + 8] = np.uint8(np.clip(block, 0, 255))

        # Переходим к следующему биту голограммы
        hologram_index += 1

cv2.imwrite('output.png', img)


def extract_hologram(container_image, length):
    h, w, _ = container_image.shape
    bits = []

    for i in range(0, h, 8):
        for j in range(0, w, 8):
            if len(bits) >= length:  # Если мы извлекли достаточное количество бит
                break
            for k in range(3):
                block = np.float32(container_image[i:i+8, j:j+8, k])
                dct_block = cv2.dct(block)
                coef1, coef2 = dct_block[5, 2], dct_block[3, 5]
                diff = coef1 - coef2
                bits.append('1' if diff > 0 else '0')

    return ''.join(bits)[:length]  # Возвращаем только первые `length` бит

embedded_img = cv2.imread('output.png')

# Извлечение голограммы
extracted_hologram_bits = extract_hologram(embedded_img, len(hologram))

# Чтение внедренного изображения
embedded_img = cv2.imread('output.png')

# Извлечение голограммы
extracted_hologram_bits = extract_hologram(embedded_img, len(hologram))

# Преобразование битов голограммы в изображение
extracted_hologram = np.array([int(extracted_hologram_bits[i:i+8], 2) for i in range(0, len(extracted_hologram_bits), 8)])
extracted_hologram = np.reshape(extracted_hologram, hologram_img.shape)

# Сохранение извлеченной голограммы
cv2.imwrite('extracted_hologram.png', extracted_hologram)






Метод, который мы использовали в этом коде, является комбинацией двух различных методов: преобразование Фурье для создания голограммы и метод Коха-Жао для внедрения голограммы в изображение-контейнер. 

1. Преобразование Фурье для создания голограммы: Преобразование Фурье - это математический метод, позволяющий разложить сложный сигнал на множество более простых синусоидальных сигналов. В контексте обработки изображений это позволяет нам перевести изображение из пространственного представления (где каждый пиксель представляет цвет в определенной точке) в частотное представление (где каждый "пиксель" представляет частоту определенного паттерна на изображении). В этом коде мы используем преобразование Фурье для создания голограммы из изображения, преобразуя его в частотное представление и сохраняя только определенные частоты.

2. Метод Коха-Жао для внедрения голограммы: Метод Коха-Жао - это метод стеганографии, который использует дискретное косинусное преобразование (ДКП) для внедрения данных в изображение. Он работает, меняя некоторые коэффициенты ДКП изображения таким образом, чтобы внедрить биты данных (в данном случае - голограммы). В частности, он выбирает два коэффициента и меняет их относительные значения, чтобы внедрить один бит данных.

Почему может быть сложно извлечь голограмму обратно? Есть несколько причин:

1. Потеря данных: Как уже упоминалось, метод Коха-Жао является методом водяного знака и не гарантирует безупречное восстановление внедренных данных. Если изображение-контейнер слишком сложное или голограмма слишком большая, то в процессе внедрения и извлечения могут произойти потери данных.

2. Искажение из-за преобразований: И преобразование Фурье, и ДКП являются преобразованиями, которые могут исказить изначальные данные. 

В частности, при использовании ДКП для внедрения голограммы мы меняем некоторые коэффициенты изображения-контейнера, что может привести к его искажению.

3. Сложность метода: Метод Коха-Жао требует точного знания того, какие коэффициенты были изменены для внедрения голограммы. Если эта информация потеряна, извлечь голограмму обратно может быть очень сложно.

Все эти факторы вместе могут затруднить точное восстановление голограммы из изображения-контейнера. Однако при правильном использовании и достаточном уровне избыточности в данных, эти методы могут быть очень эффективными для стеганографии и создания голограмм.
